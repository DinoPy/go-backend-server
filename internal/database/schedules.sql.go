// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: schedules.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO schedules (user_id, kind, title, tz, start_local, rrule, until_local,
                       show_before_minutes, notify_offsets_min, muted_offsets_min, category)
VALUES ($1, $2, $3, $4, $5, $6, $7, COALESCE($8, 0), COALESCE($9, '{2880,1440,720,360,180}')::integer[], COALESCE($10, '{}')::integer[], COALESCE($11, 'Life'))
RETURNING id, user_id, kind, title, tz, start_local, rrule, until_local, show_before_minutes, notify_offsets_min, muted_offsets_min, active, rev, last_materialized_until, created_at, updated_at, category
`

type CreateScheduleParams struct {
	UserID     uuid.UUID      `json:"user_id"`
	Kind       string         `json:"kind"`
	Title      string         `json:"title"`
	Tz         string         `json:"tz"`
	StartLocal time.Time      `json:"start_local"`
	Rrule      sql.NullString `json:"rrule"`
	UntilLocal sql.NullTime   `json:"until_local"`
	Column8    interface{}    `json:"column_8"`
	Column9    []int32        `json:"column_9"`
	Column10   []int32        `json:"column_10"`
	Column11   interface{}    `json:"column_11"`
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.db.QueryRowContext(ctx, createSchedule,
		arg.UserID,
		arg.Kind,
		arg.Title,
		arg.Tz,
		arg.StartLocal,
		arg.Rrule,
		arg.UntilLocal,
		arg.Column8,
		pq.Array(arg.Column9),
		pq.Array(arg.Column10),
		arg.Column11,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Kind,
		&i.Title,
		&i.Tz,
		&i.StartLocal,
		&i.Rrule,
		&i.UntilLocal,
		&i.ShowBeforeMinutes,
		pq.Array(&i.NotifyOffsetsMin),
		pq.Array(&i.MutedOffsetsMin),
		&i.Active,
		&i.Rev,
		&i.LastMaterializedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
	)
	return i, err
}

const deactivateSchedule = `-- name: DeactivateSchedule :exec
UPDATE schedules SET active = FALSE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeactivateSchedule(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deactivateSchedule, id)
	return err
}

const deleteSchedule = `-- name: DeleteSchedule :exec
DELETE FROM schedules WHERE id = $1
`

func (q *Queries) DeleteSchedule(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSchedule, id)
	return err
}

const getActiveSchedules = `-- name: GetActiveSchedules :many
SELECT id, user_id, kind, title, tz, start_local, rrule, until_local, show_before_minutes, notify_offsets_min, muted_offsets_min, active, rev, last_materialized_until, created_at, updated_at, category FROM schedules WHERE active = TRUE
`

func (q *Queries) GetActiveSchedules(ctx context.Context) ([]Schedule, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSchedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Kind,
			&i.Title,
			&i.Tz,
			&i.StartLocal,
			&i.Rrule,
			&i.UntilLocal,
			&i.ShowBeforeMinutes,
			pq.Array(&i.NotifyOffsetsMin),
			pq.Array(&i.MutedOffsetsMin),
			&i.Active,
			&i.Rev,
			&i.LastMaterializedUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleByID = `-- name: GetScheduleByID :one
SELECT id, user_id, kind, title, tz, start_local, rrule, until_local, show_before_minutes, notify_offsets_min, muted_offsets_min, active, rev, last_materialized_until, created_at, updated_at, category FROM schedules WHERE id = $1
`

func (q *Queries) GetScheduleByID(ctx context.Context, id uuid.UUID) (Schedule, error) {
	row := q.db.QueryRowContext(ctx, getScheduleByID, id)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Kind,
		&i.Title,
		&i.Tz,
		&i.StartLocal,
		&i.Rrule,
		&i.UntilLocal,
		&i.ShowBeforeMinutes,
		pq.Array(&i.NotifyOffsetsMin),
		pq.Array(&i.MutedOffsetsMin),
		&i.Active,
		&i.Rev,
		&i.LastMaterializedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
	)
	return i, err
}

const getSchedulesByUser = `-- name: GetSchedulesByUser :many
SELECT id, user_id, kind, title, tz, start_local, rrule, until_local, show_before_minutes, notify_offsets_min, muted_offsets_min, active, rev, last_materialized_until, created_at, updated_at, category FROM schedules WHERE user_id = $1 AND active = TRUE ORDER BY created_at DESC
`

func (q *Queries) GetSchedulesByUser(ctx context.Context, userID uuid.UUID) ([]Schedule, error) {
	rows, err := q.db.QueryContext(ctx, getSchedulesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Kind,
			&i.Title,
			&i.Tz,
			&i.StartLocal,
			&i.Rrule,
			&i.UntilLocal,
			&i.ShowBeforeMinutes,
			pq.Array(&i.NotifyOffsetsMin),
			pq.Array(&i.MutedOffsetsMin),
			&i.Active,
			&i.Rev,
			&i.LastMaterializedUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementScheduleRev = `-- name: IncrementScheduleRev :exec
UPDATE schedules SET rev = rev + 1, updated_at = NOW() WHERE id = $1
`

func (q *Queries) IncrementScheduleRev(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementScheduleRev, id)
	return err
}

const setLastMaterializedUntil = `-- name: SetLastMaterializedUntil :exec
UPDATE schedules SET last_materialized_until = $2, updated_at = NOW() WHERE id = $1
`

type SetLastMaterializedUntilParams struct {
	ID                    uuid.UUID    `json:"id"`
	LastMaterializedUntil sql.NullTime `json:"last_materialized_until"`
}

func (q *Queries) SetLastMaterializedUntil(ctx context.Context, arg SetLastMaterializedUntilParams) error {
	_, err := q.db.ExecContext(ctx, setLastMaterializedUntil, arg.ID, arg.LastMaterializedUntil)
	return err
}

const updateSchedule = `-- name: UpdateSchedule :one
UPDATE schedules 
SET title = $2, tz = $3, start_local = $4, rrule = $5, until_local = $6,
    show_before_minutes = $7, notify_offsets_min = $8, muted_offsets_min = $9,
    category = $10, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, kind, title, tz, start_local, rrule, until_local, show_before_minutes, notify_offsets_min, muted_offsets_min, active, rev, last_materialized_until, created_at, updated_at, category
`

type UpdateScheduleParams struct {
	ID                uuid.UUID      `json:"id"`
	Title             string         `json:"title"`
	Tz                string         `json:"tz"`
	StartLocal        time.Time      `json:"start_local"`
	Rrule             sql.NullString `json:"rrule"`
	UntilLocal        sql.NullTime   `json:"until_local"`
	ShowBeforeMinutes sql.NullInt32  `json:"show_before_minutes"`
	NotifyOffsetsMin  []int32        `json:"notify_offsets_min"`
	MutedOffsetsMin   []int32        `json:"muted_offsets_min"`
	Category          sql.NullString `json:"category"`
}

func (q *Queries) UpdateSchedule(ctx context.Context, arg UpdateScheduleParams) (Schedule, error) {
	row := q.db.QueryRowContext(ctx, updateSchedule,
		arg.ID,
		arg.Title,
		arg.Tz,
		arg.StartLocal,
		arg.Rrule,
		arg.UntilLocal,
		arg.ShowBeforeMinutes,
		pq.Array(arg.NotifyOffsetsMin),
		pq.Array(arg.MutedOffsetsMin),
		arg.Category,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Kind,
		&i.Title,
		&i.Tz,
		&i.StartLocal,
		&i.Rrule,
		&i.UntilLocal,
		&i.ShowBeforeMinutes,
		pq.Array(&i.NotifyOffsetsMin),
		pq.Array(&i.MutedOffsetsMin),
		&i.Active,
		&i.Rev,
		&i.LastMaterializedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
	)
	return i, err
}
