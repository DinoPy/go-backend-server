// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: notification_jobs.sql

package database

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const cancelFutureJobsForSchedule = `-- name: CancelFutureJobsForSchedule :exec
UPDATE notification_jobs
SET canceled_at = now()
WHERE schedule_id = $1
  AND sent_at IS NULL
  AND canceled_at IS NULL
  AND planned_send_at > now()
`

func (q *Queries) CancelFutureJobsForSchedule(ctx context.Context, scheduleID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, cancelFutureJobsForSchedule, scheduleID)
	return err
}

const claimDueNotificationJobs = `-- name: ClaimDueNotificationJobs :many
WITH due AS (
  SELECT id
  FROM notification_jobs
  WHERE planned_send_at <= now()
    AND sent_at IS NULL
    AND canceled_at IS NULL
  ORDER BY planned_send_at
  LIMIT $1
  FOR UPDATE SKIP LOCKED
)
UPDATE notification_jobs j
SET sent_at = now()
FROM due
WHERE j.id = due.id
RETURNING j.id, j.user_id, j.schedule_id, j.occurrence_id, j.offset_minutes, j.payload, j.planned_send_at
`

type ClaimDueNotificationJobsRow struct {
	ID            uuid.UUID       `json:"id"`
	UserID        uuid.UUID       `json:"user_id"`
	ScheduleID    uuid.NullUUID   `json:"schedule_id"`
	OccurrenceID  uuid.UUID       `json:"occurrence_id"`
	OffsetMinutes int32           `json:"offset_minutes"`
	Payload       json.RawMessage `json:"payload"`
	PlannedSendAt time.Time       `json:"planned_send_at"`
}

func (q *Queries) ClaimDueNotificationJobs(ctx context.Context, limit int32) ([]ClaimDueNotificationJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, claimDueNotificationJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClaimDueNotificationJobsRow
	for rows.Next() {
		var i ClaimDueNotificationJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ScheduleID,
			&i.OccurrenceID,
			&i.OffsetMinutes,
			&i.Payload,
			&i.PlannedSendAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationJobsByUser = `-- name: GetNotificationJobsByUser :many
SELECT id, user_id, schedule_id, occurrence_id, offset_minutes, planned_send_at, sent_at, canceled_at, payload FROM notification_jobs 
WHERE user_id = $1 
ORDER BY planned_send_at ASC
`

func (q *Queries) GetNotificationJobsByUser(ctx context.Context, userID uuid.UUID) ([]NotificationJob, error) {
	rows, err := q.db.QueryContext(ctx, getNotificationJobsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationJob
	for rows.Next() {
		var i NotificationJob
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ScheduleID,
			&i.OccurrenceID,
			&i.OffsetMinutes,
			&i.PlannedSendAt,
			&i.SentAt,
			&i.CanceledAt,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingNotificationJobs = `-- name: GetPendingNotificationJobs :many
SELECT id, user_id, schedule_id, occurrence_id, offset_minutes, planned_send_at, sent_at, canceled_at, payload FROM notification_jobs 
WHERE sent_at IS NULL 
  AND canceled_at IS NULL
ORDER BY planned_send_at ASC
`

func (q *Queries) GetPendingNotificationJobs(ctx context.Context) ([]NotificationJob, error) {
	rows, err := q.db.QueryContext(ctx, getPendingNotificationJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationJob
	for rows.Next() {
		var i NotificationJob
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ScheduleID,
			&i.OccurrenceID,
			&i.OffsetMinutes,
			&i.PlannedSendAt,
			&i.SentAt,
			&i.CanceledAt,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertNotificationJob = `-- name: UpsertNotificationJob :exec
INSERT INTO notification_jobs (user_id, schedule_id, occurrence_id, offset_minutes, planned_send_at, payload)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (occurrence_id, offset_minutes)
DO UPDATE SET planned_send_at = EXCLUDED.planned_send_at,
              payload = EXCLUDED.payload
`

type UpsertNotificationJobParams struct {
	UserID        uuid.UUID       `json:"user_id"`
	ScheduleID    uuid.NullUUID   `json:"schedule_id"`
	OccurrenceID  uuid.UUID       `json:"occurrence_id"`
	OffsetMinutes int32           `json:"offset_minutes"`
	PlannedSendAt time.Time       `json:"planned_send_at"`
	Payload       json.RawMessage `json:"payload"`
}

func (q *Queries) UpsertNotificationJob(ctx context.Context, arg UpsertNotificationJobParams) error {
	_, err := q.db.ExecContext(ctx, upsertNotificationJob,
		arg.UserID,
		arg.ScheduleID,
		arg.OccurrenceID,
		arg.OffsetMinutes,
		arg.PlannedSendAt,
		arg.Payload,
	)
	return err
}
