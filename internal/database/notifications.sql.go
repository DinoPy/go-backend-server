// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: notifications.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const archiveAllNotifications = `-- name: ArchiveAllNotifications :many
UPDATE notifications
SET status = 'archived',
	archived_at = NOW(),
	snoozed_until = NULL,
	updated_at = NOW(),
	last_modified_at = $2
WHERE user_id = $1 AND status IN ('unseen', 'seen')
RETURNING id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
`

type ArchiveAllNotificationsParams struct {
	UserID         uuid.UUID `json:"user_id"`
	LastModifiedAt int64     `json:"last_modified_at"`
}

func (q *Queries) ArchiveAllNotifications(ctx context.Context, arg ArchiveAllNotificationsParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, archiveAllNotifications, arg.UserID, arg.LastModifiedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.NotificationType,
			&i.Payload,
			&i.Priority,
			&i.ExpiresAt,
			&i.SnoozedUntil,
			&i.ActionUrl,
			&i.ActionText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastModifiedAt,
			&i.SeenAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const archiveNotification = `-- name: ArchiveNotification :one
UPDATE notifications
SET status = 'archived',
	archived_at = NOW(),
	snoozed_until = NULL,
	updated_at = NOW(),
	last_modified_at = $3
WHERE id = $1
  AND user_id = $2
RETURNING id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
`

type ArchiveNotificationParams struct {
	ID             uuid.UUID `json:"id"`
	UserID         uuid.UUID `json:"user_id"`
	LastModifiedAt int64     `json:"last_modified_at"`
}

func (q *Queries) ArchiveNotification(ctx context.Context, arg ArchiveNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, archiveNotification, arg.ID, arg.UserID, arg.LastModifiedAt)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.NotificationType,
		&i.Payload,
		&i.Priority,
		&i.ExpiresAt,
		&i.SnoozedUntil,
		&i.ActionUrl,
		&i.ActionText,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastModifiedAt,
		&i.SeenAt,
		&i.ArchivedAt,
	)
	return i, err
}

const countUnseenNotifications = `-- name: CountUnseenNotifications :one
SELECT COUNT(*) as count
FROM notifications
WHERE user_id = $1 
  AND status = 'unseen'
  AND (snoozed_until IS NULL OR snoozed_until <= NOW())
`

func (q *Queries) CountUnseenNotifications(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnseenNotifications, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (
	id,
	user_id,
	title,
	description,
	status,
	notification_type,
	payload,
	priority,
	expires_at,
	snoozed_until,
	action_url,
	action_text,
	last_modified_at,
	seen_at,
	archived_at
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	$9,
	$10,
	$11,
	$12,
	$13,
	$14,
	$15
) RETURNING id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
`

type CreateNotificationParams struct {
	ID               uuid.UUID       `json:"id"`
	UserID           uuid.UUID       `json:"user_id"`
	Title            string          `json:"title"`
	Description      sql.NullString  `json:"description"`
	Status           string          `json:"status"`
	NotificationType string          `json:"notification_type"`
	Payload          json.RawMessage `json:"payload"`
	Priority         string          `json:"priority"`
	ExpiresAt        sql.NullTime    `json:"expires_at"`
	SnoozedUntil     sql.NullTime    `json:"snoozed_until"`
	ActionUrl        sql.NullString  `json:"action_url"`
	ActionText       sql.NullString  `json:"action_text"`
	LastModifiedAt   int64           `json:"last_modified_at"`
	SeenAt           sql.NullTime    `json:"seen_at"`
	ArchivedAt       sql.NullTime    `json:"archived_at"`
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, createNotification,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.NotificationType,
		arg.Payload,
		arg.Priority,
		arg.ExpiresAt,
		arg.SnoozedUntil,
		arg.ActionUrl,
		arg.ActionText,
		arg.LastModifiedAt,
		arg.SeenAt,
		arg.ArchivedAt,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.NotificationType,
		&i.Payload,
		&i.Priority,
		&i.ExpiresAt,
		&i.SnoozedUntil,
		&i.ActionUrl,
		&i.ActionText,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastModifiedAt,
		&i.SeenAt,
		&i.ArchivedAt,
	)
	return i, err
}

const getExpiredNotifications = `-- name: GetExpiredNotifications :many
SELECT id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
FROM notifications
WHERE expires_at IS NOT NULL 
  AND expires_at < NOW()
  AND status != 'archived'
  AND (snoozed_until IS NULL OR snoozed_until <= NOW())
ORDER BY expires_at ASC
`

func (q *Queries) GetExpiredNotifications(ctx context.Context) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getExpiredNotifications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.NotificationType,
			&i.Payload,
			&i.Priority,
			&i.ExpiresAt,
			&i.SnoozedUntil,
			&i.ActionUrl,
			&i.ActionText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastModifiedAt,
			&i.SeenAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
FROM notifications
WHERE id = $1
`

func (q *Queries) GetNotificationByID(ctx context.Context, id uuid.UUID) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotificationByID, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.NotificationType,
		&i.Payload,
		&i.Priority,
		&i.ExpiresAt,
		&i.SnoozedUntil,
		&i.ActionUrl,
		&i.ActionText,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastModifiedAt,
		&i.SeenAt,
		&i.ArchivedAt,
	)
	return i, err
}

const getNotificationByTaskAndType = `-- name: GetNotificationByTaskAndType :one
SELECT id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
FROM notifications
WHERE user_id = $1
  AND notification_type = $2
  AND payload->>'task_id' = $3
  AND created_at > NOW() - INTERVAL '1 hour'
ORDER BY created_at DESC
LIMIT 1
`

type GetNotificationByTaskAndTypeParams struct {
	UserID           uuid.UUID       `json:"user_id"`
	NotificationType string          `json:"notification_type"`
	Payload          json.RawMessage `json:"payload"`
}

func (q *Queries) GetNotificationByTaskAndType(ctx context.Context, arg GetNotificationByTaskAndTypeParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotificationByTaskAndType, arg.UserID, arg.NotificationType, arg.Payload)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.NotificationType,
		&i.Payload,
		&i.Priority,
		&i.ExpiresAt,
		&i.SnoozedUntil,
		&i.ActionUrl,
		&i.ActionText,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastModifiedAt,
		&i.SeenAt,
		&i.ArchivedAt,
	)
	return i, err
}

const getNotificationsByType = `-- name: GetNotificationsByType :many
SELECT id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
FROM notifications
WHERE user_id = $1 AND notification_type = $2
  AND (snoozed_until IS NULL OR snoozed_until <= NOW())
ORDER BY created_at DESC, id DESC
LIMIT COALESCE($3::int, 50)
OFFSET COALESCE($4::int, 0)
`

type GetNotificationsByTypeParams struct {
	UserID           uuid.UUID `json:"user_id"`
	NotificationType string    `json:"notification_type"`
	Column3          int32     `json:"column_3"`
	Column4          int32     `json:"column_4"`
}

func (q *Queries) GetNotificationsByType(ctx context.Context, arg GetNotificationsByTypeParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getNotificationsByType,
		arg.UserID,
		arg.NotificationType,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.NotificationType,
			&i.Payload,
			&i.Priority,
			&i.ExpiresAt,
			&i.SnoozedUntil,
			&i.ActionUrl,
			&i.ActionText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastModifiedAt,
			&i.SeenAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasNotificationForTaskStage = `-- name: HasNotificationForTaskStage :one
SELECT EXISTS (
	SELECT 1
	FROM notifications
	WHERE user_id = $1
	  AND notification_type = $2
	  AND payload->>'task_id' = $3
	  AND payload->>'stage' = $4
	  AND created_at > NOW() - INTERVAL '5 minutes'
) AS exists
`

type HasNotificationForTaskStageParams struct {
	UserID           uuid.UUID       `json:"user_id"`
	NotificationType string          `json:"notification_type"`
	Payload          json.RawMessage `json:"payload"`
	Payload_2        json.RawMessage `json:"payload_2"`
}

func (q *Queries) HasNotificationForTaskStage(ctx context.Context, arg HasNotificationForTaskStageParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasNotificationForTaskStage,
		arg.UserID,
		arg.NotificationType,
		arg.Payload,
		arg.Payload_2,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listNotificationsByUser = `-- name: ListNotificationsByUser :many
SELECT id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
FROM notifications
WHERE user_id = $1
  AND ($2::text[] IS NULL OR status = ANY($2::text[]))
  AND ($3::text[] IS NULL OR notification_type = ANY($3::text[]))
  AND ($4::text[] IS NULL OR priority = ANY($4::text[]))
  AND ($5::bool IS DISTINCT FROM TRUE OR (expires_at IS NOT NULL AND expires_at < NOW()))
  AND ($6::bool IS TRUE OR snoozed_until IS NULL OR snoozed_until <= NOW())
ORDER BY created_at DESC, id DESC
LIMIT COALESCE($8::int, 50)
OFFSET COALESCE($7::int, 0)
`

type ListNotificationsByUserParams struct {
	UserID            uuid.UUID     `json:"user_id"`
	Statuses          []string      `json:"statuses"`
	NotificationTypes []string      `json:"notification_types"`
	Priorities        []string      `json:"priorities"`
	ExpiredOnly       sql.NullBool  `json:"expired_only"`
	IncludeSnoozed    sql.NullBool  `json:"include_snoozed"`
	OffsetVal         sql.NullInt32 `json:"offset_val"`
	LimitVal          sql.NullInt32 `json:"limit_val"`
}

func (q *Queries) ListNotificationsByUser(ctx context.Context, arg ListNotificationsByUserParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, listNotificationsByUser,
		arg.UserID,
		pq.Array(arg.Statuses),
		pq.Array(arg.NotificationTypes),
		pq.Array(arg.Priorities),
		arg.ExpiredOnly,
		arg.IncludeSnoozed,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.NotificationType,
			&i.Payload,
			&i.Priority,
			&i.ExpiresAt,
			&i.SnoozedUntil,
			&i.ActionUrl,
			&i.ActionText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastModifiedAt,
			&i.SeenAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllNotificationsSeen = `-- name: MarkAllNotificationsSeen :many
UPDATE notifications
SET status = 'seen',
	seen_at = COALESCE(seen_at, NOW()),
	snoozed_until = NULL,
	updated_at = NOW(),
	last_modified_at = $2
WHERE user_id = $1 AND status = 'unseen'
RETURNING id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
`

type MarkAllNotificationsSeenParams struct {
	UserID         uuid.UUID `json:"user_id"`
	LastModifiedAt int64     `json:"last_modified_at"`
}

func (q *Queries) MarkAllNotificationsSeen(ctx context.Context, arg MarkAllNotificationsSeenParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, markAllNotificationsSeen, arg.UserID, arg.LastModifiedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.NotificationType,
			&i.Payload,
			&i.Priority,
			&i.ExpiresAt,
			&i.SnoozedUntil,
			&i.ActionUrl,
			&i.ActionText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastModifiedAt,
			&i.SeenAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationSeen = `-- name: MarkNotificationSeen :one
UPDATE notifications
SET status = 'seen',
	seen_at = COALESCE(seen_at, NOW()),
	snoozed_until = NULL,
	updated_at = NOW(),
	last_modified_at = $3
WHERE id = $1
  AND user_id = $2
RETURNING id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
`

type MarkNotificationSeenParams struct {
	ID             uuid.UUID `json:"id"`
	UserID         uuid.UUID `json:"user_id"`
	LastModifiedAt int64     `json:"last_modified_at"`
}

func (q *Queries) MarkNotificationSeen(ctx context.Context, arg MarkNotificationSeenParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, markNotificationSeen, arg.ID, arg.UserID, arg.LastModifiedAt)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.NotificationType,
		&i.Payload,
		&i.Priority,
		&i.ExpiresAt,
		&i.SnoozedUntil,
		&i.ActionUrl,
		&i.ActionText,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastModifiedAt,
		&i.SeenAt,
		&i.ArchivedAt,
	)
	return i, err
}

const markNotificationsSeen = `-- name: MarkNotificationsSeen :many
UPDATE notifications
SET status = 'seen',
	seen_at = NOW(),
	snoozed_until = NULL,
	updated_at = NOW(),
	last_modified_at = $1
WHERE user_id = $2
  AND id = ANY($3::uuid[])
  AND status != 'archived'
RETURNING id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
`

type MarkNotificationsSeenParams struct {
	LastModifiedAt  int64       `json:"last_modified_at"`
	UserID          uuid.UUID   `json:"user_id"`
	NotificationIds []uuid.UUID `json:"notification_ids"`
}

func (q *Queries) MarkNotificationsSeen(ctx context.Context, arg MarkNotificationsSeenParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, markNotificationsSeen, arg.LastModifiedAt, arg.UserID, pq.Array(arg.NotificationIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.NotificationType,
			&i.Payload,
			&i.Priority,
			&i.ExpiresAt,
			&i.SnoozedUntil,
			&i.ActionUrl,
			&i.ActionText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastModifiedAt,
			&i.SeenAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseDueSnoozedNotifications = `-- name: ReleaseDueSnoozedNotifications :many
UPDATE notifications
SET snoozed_until = NULL,
	status = 'unseen',
	seen_at = NULL,
	updated_at = NOW(),
	last_modified_at = $1
WHERE snoozed_until IS NOT NULL
  AND snoozed_until <= NOW()
  AND status != 'archived'
RETURNING id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
`

func (q *Queries) ReleaseDueSnoozedNotifications(ctx context.Context, lastModifiedAt int64) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, releaseDueSnoozedNotifications, lastModifiedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.NotificationType,
			&i.Payload,
			&i.Priority,
			&i.ExpiresAt,
			&i.SnoozedUntil,
			&i.ActionUrl,
			&i.ActionText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastModifiedAt,
			&i.SeenAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const snoozeNotification = `-- name: SnoozeNotification :one
UPDATE notifications
SET snoozed_until = $2,
	status = 'unseen',
	seen_at = NULL,
	updated_at = NOW(),
	last_modified_at = $4
WHERE id = $1
  AND user_id = $3
  AND status != 'archived'
RETURNING id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
`

type SnoozeNotificationParams struct {
	ID             uuid.UUID    `json:"id"`
	SnoozedUntil   sql.NullTime `json:"snoozed_until"`
	UserID         uuid.UUID    `json:"user_id"`
	LastModifiedAt int64        `json:"last_modified_at"`
}

func (q *Queries) SnoozeNotification(ctx context.Context, arg SnoozeNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, snoozeNotification,
		arg.ID,
		arg.SnoozedUntil,
		arg.UserID,
		arg.LastModifiedAt,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.NotificationType,
		&i.Payload,
		&i.Priority,
		&i.ExpiresAt,
		&i.SnoozedUntil,
		&i.ActionUrl,
		&i.ActionText,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastModifiedAt,
		&i.SeenAt,
		&i.ArchivedAt,
	)
	return i, err
}

const updateNotificationDetails = `-- name: UpdateNotificationDetails :one
UPDATE notifications
SET title = $2,
	description = $3,
	notification_type = $4,
	payload = $5,
	priority = $6,
	expires_at = $7,
	action_url = $8,
	action_text = $9,
	snoozed_until = $10,
	status = $11,
	updated_at = NOW(),
	last_modified_at = $12,
	seen_at = CASE WHEN $11 = 'seen' THEN COALESCE(seen_at, NOW()) ELSE seen_at END,
	archived_at = CASE WHEN $11 = 'archived' THEN COALESCE(archived_at, NOW()) ELSE archived_at END
WHERE id = $1
RETURNING id, user_id, title, description, status, notification_type, payload, priority, expires_at, snoozed_until, action_url, action_text, created_at, updated_at, last_modified_at, seen_at, archived_at
`

type UpdateNotificationDetailsParams struct {
	ID               uuid.UUID       `json:"id"`
	Title            string          `json:"title"`
	Description      sql.NullString  `json:"description"`
	NotificationType string          `json:"notification_type"`
	Payload          json.RawMessage `json:"payload"`
	Priority         string          `json:"priority"`
	ExpiresAt        sql.NullTime    `json:"expires_at"`
	ActionUrl        sql.NullString  `json:"action_url"`
	ActionText       sql.NullString  `json:"action_text"`
	SnoozedUntil     sql.NullTime    `json:"snoozed_until"`
	Status           string          `json:"status"`
	LastModifiedAt   int64           `json:"last_modified_at"`
}

func (q *Queries) UpdateNotificationDetails(ctx context.Context, arg UpdateNotificationDetailsParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, updateNotificationDetails,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.NotificationType,
		arg.Payload,
		arg.Priority,
		arg.ExpiresAt,
		arg.ActionUrl,
		arg.ActionText,
		arg.SnoozedUntil,
		arg.Status,
		arg.LastModifiedAt,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.NotificationType,
		&i.Payload,
		&i.Priority,
		&i.ExpiresAt,
		&i.SnoozedUntil,
		&i.ActionUrl,
		&i.ActionText,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastModifiedAt,
		&i.SeenAt,
		&i.ArchivedAt,
	)
	return i, err
}
