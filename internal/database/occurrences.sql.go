// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: occurrences.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteFutureOccurrencesForSchedule = `-- name: DeleteFutureOccurrencesForSchedule :exec
DELETE FROM occurrences
WHERE schedule_id = $1 AND occurs_at > now()
`

func (q *Queries) DeleteFutureOccurrencesForSchedule(ctx context.Context, scheduleID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteFutureOccurrencesForSchedule, scheduleID)
	return err
}

const deleteOldOccurrences = `-- name: DeleteOldOccurrences :exec
DELETE FROM occurrences
WHERE occurs_at < now() - INTERVAL '14 days'
`

func (q *Queries) DeleteOldOccurrences(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteOldOccurrences)
	return err
}

const getOccurrencesBySchedule = `-- name: GetOccurrencesBySchedule :many
SELECT id, schedule_id, occurs_at, rev FROM occurrences 
WHERE schedule_id = $1 
ORDER BY occurs_at ASC
`

func (q *Queries) GetOccurrencesBySchedule(ctx context.Context, scheduleID uuid.UUID) ([]Occurrence, error) {
	rows, err := q.db.QueryContext(ctx, getOccurrencesBySchedule, scheduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Occurrence
	for rows.Next() {
		var i Occurrence
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.OccursAt,
			&i.Rev,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOccurrencesInRange = `-- name: GetOccurrencesInRange :many
SELECT id, schedule_id, occurs_at, rev FROM occurrences 
WHERE occurs_at >= $1 AND occurs_at <= $2
ORDER BY occurs_at ASC
`

type GetOccurrencesInRangeParams struct {
	OccursAt   time.Time `json:"occurs_at"`
	OccursAt_2 time.Time `json:"occurs_at_2"`
}

func (q *Queries) GetOccurrencesInRange(ctx context.Context, arg GetOccurrencesInRangeParams) ([]Occurrence, error) {
	rows, err := q.db.QueryContext(ctx, getOccurrencesInRange, arg.OccursAt, arg.OccursAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Occurrence
	for rows.Next() {
		var i Occurrence
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.OccursAt,
			&i.Rev,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertOccurrence = `-- name: UpsertOccurrence :one
INSERT INTO occurrences (schedule_id, occurs_at, rev)
VALUES ($1, $2, $3)
ON CONFLICT (schedule_id, occurs_at)
DO UPDATE SET rev = EXCLUDED.rev
RETURNING id, schedule_id, occurs_at, rev
`

type UpsertOccurrenceParams struct {
	ScheduleID uuid.UUID `json:"schedule_id"`
	OccursAt   time.Time `json:"occurs_at"`
	Rev        int32     `json:"rev"`
}

func (q *Queries) UpsertOccurrence(ctx context.Context, arg UpsertOccurrenceParams) (Occurrence, error) {
	row := q.db.QueryRowContext(ctx, upsertOccurrence, arg.ScheduleID, arg.OccursAt, arg.Rev)
	var i Occurrence
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.OccursAt,
		&i.Rev,
	)
	return i, err
}
