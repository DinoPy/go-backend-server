# Taskbar 2 – WebSocket Event Reference

This note documents every WebSocket event understood by the Go backend. Each
message uses the common envelope:

```json
{
  "event": "<event_name>",
  "data": <payload>
}
```

Unless stated otherwise all timestamps are serialized as RFC 3339 strings in UTC
and all identifiers are UUID strings.

Models returned by the server use the JSON representation generated by `sqlc`:

- `Task` – the fields defined in `internal/database/models.go` (`id`,
  `title`, `description`, `created_at`, `completed_at|null`, `duration`,
  `category`, `tags`, `toggled_at|null`, `is_active`, `is_completed`,
  `user_id`, `last_modified_at`, `priority|null`, `due_at|null`,
  `show_before_due_time|null`, `visible_from|null`).
- `Notification` – `id`, `user_id`, `title`, `description|null`, `status`,
  `notification_type`, `payload` (JSON object), `priority`, `expires_at|null`,
  `snoozed_until|null`, `action_url|null`, `action_text|null`, `created_at`,
  `updated_at`, `last_modified_at`, `seen_at|null`, `archived_at|null`.
- `Schedule` – `id`, `user_id`, `kind`, `title`, `tz`, `start_local`,
  `rrule|null`, `until_local|null`, `show_before_minutes|null`,
  `notify_offsets_min[]`, `muted_offsets_min[]`, `active`, `rev`,
  `last_materialized_until|null`, `created_at`, `updated_at`,
  `category|null`.

Null-able fields are emitted as `null` when the underlying value is not present.

---

## Connection & Keep-alive

### `connect` (client → server)

Registers or authenticates a user session.

```json
{
  "event": "connect",
  "data": {
    "id": "<optional UUID – ignored>",
    "email": "john@example.com",
    "first_name": "John",
    "last_name": "Doe",
    "google_uid": "<Google UID – required>"
  }
}
```

- If the email is unknown the backend creates a new user record.
- If the email exists the `google_uid` must match the stored value.

**Success response:** `connected`

```json
{
  "event": "connected",
  "data": {
    "sid": "<connection UUID>",
    "id": "<user UUID>",
    "first_name": "John",
    "last_name": "Doe",
    "email": "john@example.com",
    "created_at": "...",
    "updated_at": "...",
    "categories": "<comma separated string or empty>",
    "key_commands": "<JSON string or empty>",
    "tasks": [<Task>, ...],
    "notifications": [<Notification>, ...],      // unseen by default
    "notifications_unseen_count": 3,
    "schedules": [<Schedule>, ...]
  }
}
```

**Failure response:** `connection_error`

```json
{
  "event": "connection_error",
  "data": {
    "type": "invalid_google_uid" | "google_uid_mismatch" | "user_creation_failed" | "database_error" | "invalid_data",
    "message": "<reason>",
    "code": 400 | 403 | 500
  }
}
```

### `ping` (server → client) / `pong` (client → server)

- The server emits `{"event":"ping","data":""}` every 5 s.  
- The client must answer with `{"event":"pong","data":{}}` (payload can be any JSON value).
- Missing a `pong` within 60 s closes the connection.

### `taskbar-update` (client → server)

Diagnostic hook. Emits `taskbar-ack` to every other session of the same user.

```json
{
  "event": "taskbar-update",
  "data": {}
}
```

**Response:** `taskbar-ack`

```json
{
  "event": "taskbar-ack",
  "data": "From <SID>"
}
```

---

## Task Events

All task mutations target the authenticated user inferred from the connection.

### `task_create` (client → server)

```json
{
  "event": "task_create",
  "data": {
    "id": "<uuid generated client side>",
    "title": "Write summary",
    "descripiton": "Markdown typo kept for compatibility",
    "created_at": "<RFC3339>",
    "completed_at": "<RFC3339>",            // required by backend; use epoch start if not completed
    "duration": "00:00:00",
    "category": "Work",
    "tags": ["writing"],
    "toggled_at": 0,
    "is_completed": false,
    "is_active": false,
    "last_modified_at": 1700000000000,      // epoch millis
    "priority": 1,                          // optional
    "due_at": "<RFC3339> | null",
    "show_before_due_time": 180             // minutes, optional
  }
}
```

- Stores the task using the provided `id`.
- `completed_at` is stored as nullable time; supply a sensible default when task is not yet completed.

**Broadcast (siblings only):** `new_task_created` with the persisted `Task`. The issuing client does not receive the echo; maintain local state optimistically.

### `task_toggle` (client → server)

```json
{
  "event": "task_toggle",
  "data": {
    "uuid": "<task id>",
    "toggled_at": 1700000000000,
    "is_active": true,
    "duration": "00:05:03",
    "last_modified_at": 1700000000001
  }
}
```

**Broadcast (others):** `related_task_toggled` with the updated `Task`.

### `task_edit` (client → server)

```json
{
  "event": "task_edit",
  "data": {
    "id": "<task id>",
    "title": "Write summary",
    "description": "Updated copy",
    "category": "Work",
    "tags": ["writing", "docs"],
    "last_modified_at": 1700000002222,
    "priority": 1,
    "due_at": "<RFC3339> | null",
    "show_before_due_time": 180
  }
}
```

**Broadcast (others):** `related_task_edited` with the updated `Task`.

### `task_completed` (client → server)

```json
{
  "event": "task_completed",
  "data": {
    "id": "<task id>",
    "completed_at": "<RFC3339>",
    "duration": "00:25:00",
    "last_modified_at": 1700001111111
  }
}
```

- Marks the task complete and removes it from the active set.

**Broadcast (others):** `related_task_deleted` with `{ "id": "<task id>" }`.

### `task_delete` (client → server)

```json
{
  "event": "task_delete",
  "data": {
    "id": "<task id>"
  }
}
```

**Broadcast (others):** `related_task_deleted` with `{ "id": "<task id>" }`.

### `task_duplicate` (client → server)

```json
{
  "event": "task_duplicate",
  "data": {
    "task_id": "<source task>"
  }
}
```

- Duplicates the source task (new `id`, zeroed duration/toggled state).

**Broadcast (all sessions):** `new_task_created` with the duplicate `Task`.

### `task_split` (client → server)

```json
{
  "event": "task_split",
  "data": {
    "task_id": "<source task>",
    "splits": [
      { "title": "Part 1", "description": "foo", "duration": "00:10:00" },
      { "title": "Part 2", "description": "bar", "duration": "00:20:00" }
    ]
  }
}
```

- Replaces the source task with multiple new tasks inside a transaction.

**Broadcast (all sessions):**
- `related_task_deleted` `{ "id": "<source task>" }`.
- `new_task_created` fired once per split task (payload is the new `Task`).

### `get_completed_tasks` (client → server)

```json
{
  "event": "get_completed_tasks",
  "data": {
    "category": "Work",                // optional
    "start_date": "<RFC3339>",         // optional, defaults to start of today
    "end_date": "<RFC3339>",           // optional, defaults to end of today
    "search_query": "summary",         // optional (substring match)
    "tags": ["writing"]                // optional, array of strings
  }
}
```

**Direct response:** `get_completed_tasks` with `data` = `[]Task`.

### `request_hard_refresh` (client → server)

Used when the client needs a fresh copy of active tasks and settings.

**Direct response:** `request_hard_refresh`

```json
{
  "event": "request_hard_refresh",
  "data": {
    "categories": "<comma separated string or empty>",
    "key_commands": "<JSON string or empty>",
    "tasks": [<Task>, ...]
  }
}
```

### `user_updated_categories` (client → server)

```json
{
  "event": "user_updated_categories",
  "data": ["Home", "Work", "Life"]
}
```

**Broadcast (others):** `related_user_updated_categories` with either a string or
`null` (depending on the DB value).

### `new_command_added` / `command_removed` (client → server)

Both events expect the full command set as a single string (often JSON).

```json
{
  "event": "new_command_added",
  "data": "{\"shortcuts\":[...]}"`
}
```

**Broadcast (others):** `related_command_updated` with the updated string (or `null`).

### Server-initiated task events

- `tasks_refresher` – emitted nightly at 23:59 Europe/Bucharest (`WSOnMidnightTaskRefresh`) and whenever the cron finishes rolling tasks:

  ```json
  {
    "event": "tasks_refresher",
    "data": {
      "categories": "<string>",
      "key_commands": "<string>",
      "tasks": [<Task>, ...]
    }
  }
  ```

- `tasks_became_visible` – emitted every minute when tasks transition into view based on `visible_from`:

  ```json
  {
    "event": "tasks_became_visible",
    "data": { "tasks": [<Task>, ...] }
  }
  ```

- `new_task_created` – emitted by schedule materialization (`ScheduleService`) and immediate reminders; payload is a `Task`.

- `related_task_toggled`, `related_task_edited`, `related_task_deleted` as described above originate both from direct commands and from schedulers.

---

## Notification Events

### `notifications_fetch` (client → server)

```json
{
  "event": "notifications_fetch",
  "data": {
    "offset": 0,                           // default 0
    "limit": 10,                           // default 10, max 100
    "statuses": ["unseen","snoozed"],      // optional
    "notification_types": ["reminder"],    // optional
    "priorities": ["high"],                // optional
    "include_snoozed": true,               // optional
    "expired_only": false                  // optional
  }
}
```

**Response (`notifications_batch`):**

```json
{
  "event": "notifications_batch",
  "data": {
    "notifications": [<Notification>, ...],
    "offset": 0,
    "limit": 10,
    "has_more": true
  }
}
```

### `notification_mark_seen` (client → server)

```json
{
  "event": "notification_mark_seen",
  "data": {
    "notification_ids": ["<uuid>", "<uuid>"]
  }
}
```

**Broadcast (all sessions):**

- `notifications_marked_seen`

  ```json
  {
    "event": "notifications_marked_seen",
    "data": {
      "notifications": [<Notification>, ...]   // updated rows
    }
  }
  ```

- `notifications_unseen_count` `{ "count": <int64> }`

### `notification_mark_all_seen` (client → server)

Accepts an optional subset of IDs; otherwise marks every notification for the
user.

**Broadcasts:** identical to `notification_mark_seen`.

### `notification_archive` (client → server)

```json
{
  "event": "notification_archive",
  "data": {
    "notification_id": "<uuid>"
  }
}
```

**Broadcast (all sessions):**

- `notification_archived` with the updated `Notification`.
- `notifications_unseen_count`.

### `notification_snooze` (client → server)

```json
{
  "event": "notification_snooze",
  "data": {
    "notification_id": "<uuid>",
    "snooze_until": 1700000005000,     // epoch millis (optional)
    "snooze_minutes": 15,              // optional
    "snooze_seconds": 90               // optional
  }
}
```

One of `snooze_until`, `snooze_minutes`, `snooze_seconds` must be supplied. If
the computed time is in the past the server enforces a minimum of 5 minutes.

**Broadcasts:**

- `notification_snoozed` with the updated `Notification`.
- `notifications_unseen_count`.

### Server-initiated notification events

- `notification_created` – emitted when a scheduled notification job is
  dispatched. Payload is a `Notification`.
- `notifications_reemitted` – produced when snoozed notifications become due:

  ```json
  {
    "event": "notifications_reemitted",
    "data": {
      "notifications": [<Notification>, ...]
    }
  }
  ```

- `notifications_unseen_count` – broadcast after any change affecting unseen
  totals (creation, snooze release, mark-seen, archive).

---

## Schedule & Reminder Events

Field semantics follow the `Schedule` struct. `kind` must be either `task` or
`reminder`. `tz` is an IANA identifier.

### `schedule_create` (client → server)

```json
{
  "event": "schedule_create",
  "data": {
    "kind": "task" | "reminder",
    "title": "Daily stand-up",
    "tz": "Europe/Bucharest",
    "start_local": "<RFC3339>",          // local time
    "rrule": "FREQ=DAILY;INTERVAL=1",    // optional
    "until_local": "<RFC3339>",          // optional
    "show_before_minutes": 15,           // optional
    "notify_offsets_min": [2880,1440],   // optional, defaults applied when omitted
    "muted_offsets_min": [0],            // optional
    "category": "Work"                   // optional, defaults to "Life"
  }
}
```

**Response:** `schedule_created` with the persisted `Schedule`.

### `schedule_edit` (client → server)

```json
{
  "event": "schedule_edit",
  "data": {
    "id": "<schedule id>",
    "title": "Daily stand-up",
    "tz": "Europe/Bucharest",
    "start_local": "<RFC3339>",
    "rrule": "FREQ=DAILY;INTERVAL=1",    // optional
    "until_local": "<RFC3339>",          // optional
    "show_before_minutes": 15,           // optional
    "notify_offsets_min": [2880,1440],
    "muted_offsets_min": [],
    "category": "Work"                   // optional
  }
}
```

- Cancels future notification jobs and occurrences before persisting changes.

**Response:** `schedule_updated` with the updated `Schedule`.

### `schedule_delete` (client → server)

```json
{
  "event": "schedule_delete",
  "data": {
    "id": "<schedule id>"
  }
}
```

- Cancels future jobs, removes occurrences, then deletes the schedule.

**Response:** `schedule_deleted` with `{ "id": "<schedule id>" }`.

### `schedule_list` (client → server)

No payload required.

**Response:** `schedules_list`

```json
{
  "event": "schedules_list",
  "data": {
    "schedules": [<Schedule>, ...]
  }
}
```

### `reminder_submit` (client → server)

Used by the natural-language reminder flow.

```json
{
  "event": "reminder_submit",
  "data": {
    "title": "Call Alice",
    "kind": "reminder" | "task",
    "scheduleInput": "<original user input>",
    "schedule": {
      "instant": {
        "label": "today",
        "iso": "<RFC3339>"
      },
      "recurrence": null           // set when using parsed recurrence
    },
    "show_before_minutes": 0,
    "category": "Life"
  }
}
```

- Exactly one of `schedule.instant` or `schedule.recurrence` must be non-null.
- `schedule.instant.iso` and `schedule.recurrence.start` are parsed with
  `time.Parse` in RFC 3339 format.

**Response:** `reminder_submit_response`

```json
{
  "event": "reminder_submit_response",
  "data": {
    "success": true,
    "schedule": <Schedule>
  }
}
```

If the instant reminder is due within two minutes, the server immediately
creates the first occurrence and may emit:

- `new_task_created` (when `kind == "task"`).
- `notification_created` (after the dispatcher processes the job).

### Server-initiated schedule events

- `new_task_created` – emitted whenever the planner materializes a task
  occurrence.
- Notification-related events described above fire as the dispatcher claims
  planned jobs.

---

## Additional Notes for Client Implementers

- Multiple sessions for the same user receive broadcasts (except where noted).
  Use the `sid` from the `connected` payload to identify the active session.
- Large lists (`notifications_batch`, `tasks_refresher`) can be streamed; there
  is no pagination on task refresh events.
- All mutation handlers may return standard WebSocket close frames when an
  unhandled error occurs; reconnect logic should retry the `connect` flow.
- Maintain an idle timeout shorter than 60 s to ensure `pong` responses stay in
  flight, otherwise the backend will close the connection.

